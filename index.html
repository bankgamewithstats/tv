<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#0f1e4a" />
  <title>Bank Game ‚Äî Live Leaderboard</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <!-- Confetti lives at body level so it isn't a flex child of any screen -->
  <canvas id="confetti-canvas"></canvas>

  <!-- Idle/waiting state -->
  <div id="waiting-screen" class="screen">
    <div class="logo-corner">
      <img src="logo.png" alt="Bank" class="logo-img" />
    </div>
    <div class="waiting-content">
      <div class="waiting-title">Bank Game with Stats</div>
      <div class="waiting-subtitle">Waiting for game...</div>
    </div>
  </div>

  <!-- End screen -->
  <div id="end-screen" class="screen hidden">
    <div class="logo-corner">
      <img src="logo.png" alt="Bank" class="logo-img" />
    </div>
    <div class="end-wrapper">
      <div class="winner-banner">
        <span class="winner-trophy">üèÜ</span>
        <span class="winner-name-text" id="winner-name-text">Game Over</span>
      </div>
      <div class="end-body">
        <div class="end-left">
          <div class="end-section-title">Final Standings</div>
          <div id="end-players-list"></div>
        </div>
        <div class="end-right">
          <div class="end-section-title">Player Awards</div>
          <div class="stats-grid" id="stat-player-awards"></div>
          <div class="end-section-title">Dice &amp; Rolls</div>
          <div class="stats-grid" id="stat-dice-rolls"></div>
          <div class="end-section-title">Game Records</div>
          <div class="stats-grid" id="stat-game-records"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Live leaderboard -->
  <div id="game-screen" class="screen hidden">
    <header class="game-header">
      <div class="round-display" id="round-display">Round 1 / 10</div>
      <span class="pot-value" id="pot-value">0</span>
      <div class="header-logo">
        <img src="logo.png" alt="Bank" class="logo-img" />
      </div>
    </header>
    <main class="leaderboard" id="players-list"></main>
  </div>

  <!-- Google Cast Receiver SDK ‚Äî no-op in non-Cast browsers -->
  <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
  <script>
    // Initialize Cast receiver if running inside Chromecast
    if (window.cast && cast.framework) {
      const context = cast.framework.CastReceiverContext.getInstance();
      const options = new cast.framework.CastReceiverOptions();
      // CRITICAL: disableIdleTimeout prevents receiver closing mid-game
      // (default: Cast closes after ~5 min with no media activity)
      options.disableIdleTimeout = true;
      context.start(options);
    }
  </script>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js';
    import { getDatabase, ref, onValue } from 'https://www.gstatic.com/firebasejs/12.9.0/firebase-database.js';

    // Firebase config ‚Äî security via rules, not key secrecy (standard Firebase practice)
    const firebaseConfig = {
      apiKey: "AIzaSyDkqm3qDC50wcvNOtdL7X2ocKImMpFTYR0",
      authDomain: "bank-game-with-stats.firebaseapp.com",
      databaseURL: "https://bank-game-with-stats-default-rtdb.firebaseio.com",
      projectId: "bank-game-with-stats",
      storageBucket: "bank-game-with-stats.appspot.com",
      messagingSenderId: "333591070423",
      appId: "1:333591070423:web:ab922405955584dfb39292"
    };

    const code = new URLSearchParams(window.location.search).get('code');

    const waitingScreen = document.getElementById('waiting-screen');
    const gameScreen = document.getElementById('game-screen');
    const endScreen = document.getElementById('end-screen');
    const roundDisplay = document.getElementById('round-display');
    const potValue = document.getElementById('pot-value');
    const playersList = document.getElementById('players-list');

    function showWaiting() {
      waitingScreen.classList.remove('hidden');
      gameScreen.classList.add('hidden');
      endScreen.classList.add('hidden');
      stopConfetti();
    }

    function showGame() {
      waitingScreen.classList.add('hidden');
      gameScreen.classList.remove('hidden');
      endScreen.classList.add('hidden');
      stopConfetti();
    }

    function showEnd() {
      waitingScreen.classList.add('hidden');
      gameScreen.classList.add('hidden');
      endScreen.classList.remove('hidden');
      startConfetti();
    }

    function formatScore(n) {
      return n.toLocaleString();
    }

    // Track previous isBanked state per player id for flash animation detection
    const prevBankedState = {};

    function renderLeaderboard(state) {
      // Show game screen
      showGame();

      // Scale leaderboard based on player count ‚Äî never let players go off screen
      const count = state.players.length;
      const cols = count > 20 ? 3 : count > 10 ? 2 : 1;
      const sizeClass = count > 20 ? ' lb-xl' : count > 10 ? ' lb-large' : count > 6 ? ' lb-small' : '';
      gameScreen.className = `screen${sizeClass}`;

      // Round display
      roundDisplay.textContent = `Round ${state.currentRound} / ${state.totalRounds}`;

      // Pot display
      potValue.textContent = formatScore(state.pot);

      // Sort players by score descending
      const sorted = [...state.players].sort((a, b) => b.score - a.score);

      // Apply column-flow layout after rendering so items read top‚Üíbottom in
      // each column rather than left‚Üíright across rows.
      // grid-auto-flow:column + explicit row count achieves this.
      if (cols > 1) {
        const rows = Math.ceil(count / cols);
        playersList.style.display = 'grid';
        playersList.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        playersList.style.gridTemplateRows = `repeat(${rows}, auto)`;
        playersList.style.gridAutoFlow = 'column';
        playersList.style.gap = '0.4rem 1rem';
        playersList.style.alignContent = 'start';
      } else {
        playersList.style.cssText = '';
      }

      playersList.innerHTML = sorted.map((player, idx) => {
        const isCurrentPlayer = state.players[state.currentPlayerIndex]?.id === player.id && !player.isBanked;
        const justBanked = !prevBankedState[player.id] && player.isBanked;

        let rowClass = 'player-row';
        if (player.isBanked) rowClass += ' banked';
        if (isCurrentPlayer) rowClass += ' current';
        if (justBanked) rowClass += ' just-banked';

        const lockIcon = player.isBanked ? '<span class="lock-icon">&#x1F512;</span>' : '';
        const currentArrow = isCurrentPlayer ? '<span class="current-arrow">&#x25B6;</span>' : '';
        const rank = idx + 1;

        return `
          <div class="${rowClass}" data-id="${player.id}">
            <span class="rank">${rank}</span>
            <span class="player-name">${escapeHtml(player.name)} ${lockIcon}</span>
            <span class="player-score">${formatScore(player.score)} ${currentArrow}</span>
          </div>
        `;
      }).join('');

      // Update previous banked state tracking
      state.players.forEach(p => {
        prevBankedState[p.id] = p.isBanked;
      });
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.appendChild(document.createTextNode(str));
      return div.innerHTML;
    }

    function statCard(label, value, description) {
      return `
        <div class="stat-card-tv">
          <div class="stat-card-label">${label}</div>
          <div class="stat-card-value">${escapeHtml(value ?? 'No data')}</div>
          <div class="stat-card-desc">${description}</div>
        </div>`;
    }

    function renderEndScreen(state) {
      showEnd();

      // Winner banner
      const names = state.winnerNames ?? [];
      document.getElementById('winner-name-text').textContent =
        names.length === 1 ? `${names[0]} Wins!` :
        names.length > 1  ? `It's a Tie! ‚Äî ${names.join(' & ')}` :
        'Game Over';

      // Final standings
      const sorted = [...state.players].sort((a, b) => b.score - a.score);
      document.getElementById('end-players-list').innerHTML = sorted.map((p, i) => {
        const isWinner = names.includes(p.name);
        return `
          <div class="end-player-row ${isWinner ? 'end-player-winner' : ''}">
            <span class="end-rank">${i + 1}</span>
            <span class="end-player-name">${escapeHtml(p.name)}</span>
            <span class="end-score">${formatScore(p.score)}</span>
          </div>`;
      }).join('');

      const s = state.stats;
      if (!s) return;

      document.getElementById('stat-player-awards').innerHTML = [
        statCard('Most Greedy Turn',
          s.mostGreedy ? `${s.mostGreedy.playerName} ‚Äî ${s.mostGreedy.rollNumber} rolls (Rd ${s.mostGreedy.roundNumber})` : null,
          'Pushed their luck the longest in a single round.'),
        statCard('Best Banker',
          s.bestBanker ? `${s.bestBanker.playerName} ‚Äî avg ${formatScore(s.bestBanker.avgAmount)} pts` : null,
          'Highest average points per successful bank.'),
        statCard('Early Cash-Out',
          s.earlyCashOut ? `${s.earlyCashOut.playerName} ‚Äî avg roll ${s.earlyCashOut.avgRolls}` : null,
          'Banked the earliest on average ‚Äî cautious and smart.'),
        statCard('Perfect Timing',
          s.perfectTiming ? `${s.perfectTiming.playerName} ‚Äî ${s.perfectTiming.count}x (best ${formatScore(s.perfectTiming.bestAmount)} pts)` : null,
          'Banked on the very last roll before a 7 crashed.'),
        statCard('Biggest Bank',
          s.biggestBank ? `${s.biggestBank.playerName} ‚Äî ${formatScore(s.biggestBank.amount)} pts (Rd ${s.biggestBank.roundNumber})` : null,
          'Single largest bank of the entire game.'),
      ].join('');

      document.getElementById('stat-dice-rolls').innerHTML = [
        statCard('Ruler of the Sevens',
          s.rulerOfSevens ? `${s.rulerOfSevens.playerName} ‚Äî ${s.rulerOfSevens.sevenCount} sevens` : null,
          'Rolled the most 7s ‚Äî safe ones and busts included.'),
        statCard('Most Doubles',
          s.mostDoubles ? `${s.mostDoubles.playerName} ‚Äî ${s.mostDoubles.doubleCount} doubles` : null,
          'Rolled the most doubles ‚Äî each one doubled the pot.'),
        statCard('Most Active Roller',
          s.mostActive ? `${s.mostActive.playerName} ‚Äî ${s.mostActive.rollCount} rolls` : null,
          'Rolled the dice the most times across the whole game.'),
        statCard('Most Common Number',
          s.mostCommonNumber ? `${s.mostCommonNumber.total} ‚Äî ${s.mostCommonNumber.count} times` : null,
          'The dice total that came up most often.'),
      ].join('');

      document.getElementById('stat-game-records').innerHTML = [
        statCard('Biggest Missed Opportunity',
          s.closestCall ? `Round ${s.closestCall.roundNumber} ‚Äî ${formatScore(s.closestCall.potAmount)} pts wiped` : null,
          'Highest pot sitting in the bank when a 7 wiped it.'),
        statCard('Wildest Round',
          s.wildestRound ? `Round ${s.wildestRound.roundNumber} ‚Äî ${s.wildestRound.rollCount} rolls` : null,
          'The round with the most total dice rolls.'),
      ].join('');
    }

    // ---- Confetti ----
    const confettiCanvas = document.getElementById('confetti-canvas');
    const ctx = confettiCanvas.getContext('2d');
    let confettiPieces = [];
    let confettiRunning = false;
    let confettiRaf = null;

    const COLORS = ['#cb9a45', '#ffffff', '#4caf50', '#2196f3', '#e91e63', '#ff9800'];

    function resizeConfetti() {
      confettiCanvas.width = confettiCanvas.offsetWidth;
      confettiCanvas.height = confettiCanvas.offsetHeight;
    }

    function spawnConfetti(count) {
      const w = confettiCanvas.width;
      for (let i = 0; i < count; i++) {
        confettiPieces.push({
          x: Math.random() * w,
          y: -10 - Math.random() * 120,
          w: 4 + Math.random() * 4,
          h: 5 + Math.random() * 4,
          color: COLORS[Math.floor(Math.random() * COLORS.length)],
          angle: Math.random() * Math.PI * 2,
          spin: (Math.random() - 0.5) * 0.15,
          vx: (Math.random() - 0.5) * 1.5,
          vy: 1.5 + Math.random() * 2.5,
          opacity: 1,
        });
      }
    }

    function tickConfetti() {
      const h = confettiCanvas.height;
      const w = confettiCanvas.width;
      ctx.clearRect(0, 0, w, h);

      confettiPieces = confettiPieces.filter(p => p.y < h + 20);

      for (const p of confettiPieces) {
        p.x += p.vx;
        p.y += p.vy;
        p.angle += p.spin;
        p.vx += (Math.random() - 0.5) * 0.1; // gentle drift

        ctx.save();
        ctx.globalAlpha = p.opacity;
        ctx.translate(p.x, p.y);
        ctx.rotate(p.angle);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
        ctx.restore();
      }

      // Keep spawning while running
      if (confettiRunning && confettiPieces.length < 60) spawnConfetti(1);

      confettiRaf = requestAnimationFrame(tickConfetti);
    }

    function startConfetti() {
      confettiPieces = [];
      confettiRunning = true;
      confettiCanvas.style.display = 'block';
      // Defer resize until after the browser reflows the newly-visible canvas
      requestAnimationFrame(() => {
        resizeConfetti();
        spawnConfetti(50); // initial burst ‚Äî smaller than before
        if (!confettiRaf) tickConfetti();
      });
    }

    function stopConfetti() {
      confettiRunning = false;
      // Let existing pieces fall off naturally, then hide canvas
      setTimeout(() => {
        cancelAnimationFrame(confettiRaf);
        confettiRaf = null;
        ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        confettiPieces = [];
        confettiCanvas.style.display = 'none';
      }, 4000);
    }

    window.addEventListener('resize', () => { if (confettiRunning) resizeConfetti(); });

    // ---- End ----

    if (!code) {
      showWaiting();
    } else {
      const app = initializeApp(firebaseConfig);
      const db = getDatabase(app);

      onValue(ref(db, `rooms/${code}`), (snapshot) => {
        const data = snapshot.val();
        if (!data || data.gamePhase === 'setup') {
          showWaiting();
        } else if (data.gamePhase === 'game-over') {
          renderEndScreen(data);
        } else {
          renderLeaderboard(data);
        }
      });
    }
  </script>
</body>
</html>
